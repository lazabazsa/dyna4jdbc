package com.github.dyna4jdbc.internal.connection.scriptengine;

import java.io.Writer;
import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.SQLWarning;
import java.sql.Statement;
import java.util.Iterator;
import java.util.List;

import javax.script.ScriptEngine;
import javax.script.ScriptException;

import com.github.dyna4jdbc.internal.ClosableSQLObject;
import com.github.dyna4jdbc.internal.SQLError;

class ScriptEngineStatement extends ClosableSQLObject implements java.sql.Statement {

	private final ScriptEngineConnection scriptEngineConnection;
	private final ResultSetFactory resultSetFactory;

	private Iterator<ResultSet> resultSetIterator;

	public ScriptEngineStatement(ScriptEngineConnection scriptEngineConnection, ResultSetFactory resultSetFactory) {
		this.scriptEngineConnection = scriptEngineConnection;
		this.resultSetFactory = resultSetFactory;
	}

	public ResultSet executeQuery(String script) throws SQLException {
		try {
			
			ResultSet resultSetToReturn;
			
			final ObjectCapturingPrintWriter objectCapturingPrintWriter = new ObjectCapturingPrintWriter();
			
			executScriptUsingCustomWriters(script, objectCapturingPrintWriter, null);

			final boolean resultsCaptured = objectCapturingPrintWriter.getCapturedAnyOutput();
			if (resultsCaptured) {

				List<Object> resultObjectList = objectCapturingPrintWriter.getUnmodifyAbleCapturedObjectList();
				
				List<ResultSet> resultSetList = resultSetFactory.newResultSets(this, resultObjectList);
				switch (resultSetList.size()) {
				case 0:
					resultSetToReturn = new EmptyResultSet();
					break;
				
				case 1:
					resultSetToReturn = resultSetList.get(0);
					break;
					
				default:
					throw SQLError.RESULT_SET_MULTIPLE_EXPECTED_ONE.raiseException(resultSetList.size());
				}
				
			} else {
				resultSetToReturn = new EmptyResultSet();
			}

			return resultSetToReturn;
		} 
		catch (ScriptException se) {
			throw SQLError.SCRIPT_EXECUTION_EXCEPTION.raiseException(se);
		}
		catch (Throwable t) {
			throw SQLError.UNEXPECTED_THROWABLE.raiseException(t);
		}
	}

	public boolean execute(final String script) throws SQLException {

		try {
			final ObjectCapturingPrintWriter objectCapturingPrintWriter = new ObjectCapturingPrintWriter();
			
			executScriptUsingCustomWriters(script, objectCapturingPrintWriter, null);

			boolean resultsCaptured = objectCapturingPrintWriter.getCapturedAnyOutput();
			if (resultsCaptured) {

				List<Object> resultObjectList = objectCapturingPrintWriter.getUnmodifyAbleCapturedObjectList();
				resultSetIterator = resultSetFactory.newResultSets(this, resultObjectList).iterator();
			}

			return resultsCaptured;
		}
		catch (ScriptException se) {
			throw SQLError.SCRIPT_EXECUTION_EXCEPTION.raiseException(se);
		}
		catch (Throwable t) {
			throw SQLError.UNEXPECTED_THROWABLE.raiseException(t);
		}
	}

	public int executeUpdate(final String script) throws SQLException {

		try {
			final DisallowAllWritesPrintWriter printWriter = DisallowAllWritesPrintWriter
					.forMessage(SQLError.USING_STDOUT_FROM_UPDATE.toString());

			executScriptUsingCustomWriters(script, printWriter, null);

			return 0;

		}
		catch (ScriptException se) {
			throw SQLError.SCRIPT_EXECUTION_EXCEPTION.raiseException(se);
		}
		catch (Throwable t) {
			throw SQLError.UNEXPECTED_THROWABLE.raiseException(t);
		}
	}

	private void executScriptUsingCustomWriters(final String script, Writer outWriter, Writer errorWriter)
			throws ScriptException {

		ExecuteScriptUsingCustomPrintWriter customWritersCallback = new ExecuteScriptUsingCustomPrintWriter(script,
				outWriter, errorWriter);

		scriptEngineConnection.executeUsingScriptEngine(customWritersCallback);
	}

	private static final class ExecuteScriptUsingCustomPrintWriter
			implements ScriptEngineConnection.ScriptEngineCallback<Void> {

		private final String script;
		private final Writer outWriter;
		private final Writer errorWriter;

		private ExecuteScriptUsingCustomPrintWriter(String script, Writer outWriter, Writer errorWriter) {
			this.script = script;
			this.outWriter = outWriter;
			this.errorWriter = errorWriter;
		}

		public Void execute(ScriptEngine engine) throws ScriptException {

			if (outWriter != null) {
				engine.getContext().setWriter(outWriter);
			}

			if (errorWriter != null) {
				engine.getContext().setErrorWriter(errorWriter);
			}

			engine.eval(script);

			return null;
		}
	}

	public int executeUpdate(String sql, int autoGeneratedKeys) throws SQLException {
		throw SQLError.JDBC_FUNCTION_NOT_SUPPORTED.raiseException(
				"java.sql.Statement.executeUpdate(String, int)");
	}

	public int executeUpdate(String sql, int[] columnIndexes) throws SQLException {
		throw SQLError.JDBC_FUNCTION_NOT_SUPPORTED.raiseException(
				"java.sql.Statement.executeUpdate(String, int[])");
	}

	public int executeUpdate(String sql, String[] columnNames) throws SQLException {
		throw SQLError.JDBC_FUNCTION_NOT_SUPPORTED.raiseException(
				"java.sql.Statement.executeUpdate(String, String[])");
	}

	public boolean execute(String sql, int autoGeneratedKeys) throws SQLException {
		throw SQLError.JDBC_FUNCTION_NOT_SUPPORTED.raiseException(
				"java.sql.Statement.execute(String, int)");
	}

	public boolean execute(String sql, int[] columnIndexes) throws SQLException {
		throw SQLError.JDBC_FUNCTION_NOT_SUPPORTED.raiseException(
				"java.sql.Statement.execute(String, int[])");
	}

	public boolean execute(String sql, String[] columnNames) throws SQLException {
		throw SQLError.JDBC_FUNCTION_NOT_SUPPORTED.raiseException(
				"java.sql.Statement.execute(String, String[])");
	}

	public int getMaxFieldSize() throws SQLException {
		return 0;
	}

	public void setMaxFieldSize(int max) throws SQLException {
		// TODO: implement
	}

	public int getMaxRows() throws SQLException {
		return 0; // no limit
	}

	public void setMaxRows(int max) throws SQLException {
		// TODO: implement
	}

	public void setEscapeProcessing(boolean enable) throws SQLException {

	}

	public int getQueryTimeout() throws SQLException {
		return 0;
	}

	public void setQueryTimeout(int seconds) throws SQLException {

	}

	public void cancel() throws SQLException {
		SQLError.JDBC_FUNCTION_NOT_SUPPORTED.raiseException(
				"java.sql.Statement.cancel()");
	}

	public SQLWarning getWarnings() throws SQLException {
		return null;
	}

	public void clearWarnings() throws SQLException {

	}

	public void setCursorName(String name) throws SQLException {
		// No-op: "If the database does not support positioned update/delete, this method is a noop"
	}

	public ResultSet getResultSet() throws SQLException {
		
		ResultSet resultSetToReturn;
		if(resultSetIterator != null && resultSetIterator.hasNext()) { 
			resultSetToReturn = resultSetIterator.next();
		} else {
			resultSetToReturn = null;
		}
		
		return resultSetToReturn;
	}

	public int getUpdateCount() throws SQLException {
		return 0;
	}

	public boolean getMoreResults() throws SQLException {
		return resultSetIterator.hasNext();
	}
	
	public boolean getMoreResults(int current) throws SQLException {
		if(current != Statement.CLOSE_CURRENT_RESULT && 
				current != Statement.KEEP_CURRENT_RESULT && 
				current != Statement.CLOSE_ALL_RESULTS) {
			throw new SQLException("Invalid value for current: " + current);
		}
		
		if(current != Statement.CLOSE_CURRENT_RESULT) {
			throw new SQLException(
					"Only Statement.CLOSE_CURRENT_RESULT is supported: " + 
							current);
		}
		return getMoreResults();
	}

	public void setFetchDirection(int direction) throws SQLException {
		if(direction ==  ResultSet.FETCH_FORWARD ||
				direction == ResultSet.FETCH_REVERSE ||
						direction == ResultSet.FETCH_UNKNOWN) {
			// no-op: setFetchDirection is just a hint, a driver might ignore it
		}
		else {
			// signal illegal argument
			throw new SQLException("Invalid direction: " + direction);
		}
	}

	public int getFetchDirection() throws SQLException {
		return ResultSet.FETCH_FORWARD;
	}

	public void setFetchSize(int rows) throws SQLException {
		if(rows < 0) { 
			throw new SQLException("Invalid fetchSize: " + rows);
		}
		
		if(rows > 0) {
			throw SQLError.JDBC_FUNCTION_NOT_SUPPORTED.raiseException(
					"Setting a non-zero fetchSize: " + rows);
		}
		
		// zero -- no-op
	}

	public int getFetchSize() throws SQLException {
		return 0;
	}

	public int getResultSetConcurrency() throws SQLException {
		return ResultSet.CONCUR_READ_ONLY;
	}

	public int getResultSetType() throws SQLException {
		return ResultSet.TYPE_FORWARD_ONLY;
	}

	public void addBatch(String sql) throws SQLException {
		throw SQLError.JDBC_FUNCTION_NOT_SUPPORTED.raiseException(
				"java.sql.Statement.addBatch(String)");
	}

	public void clearBatch() throws SQLException {
		throw SQLError.JDBC_FUNCTION_NOT_SUPPORTED.raiseException(
				"java.sql.Statement.clearBatch()");
	}

	public int[] executeBatch() throws SQLException {
		throw SQLError.JDBC_FUNCTION_NOT_SUPPORTED.raiseException(
				"java.sql.Statement.executeBatch()");
	}

	public Connection getConnection() throws SQLException {
		return scriptEngineConnection;
	}

	public ResultSet getGeneratedKeys() throws SQLException {
		return new EmptyResultSet();
	}

	public int getResultSetHoldability() throws SQLException {
		return ResultSet.HOLD_CURSORS_OVER_COMMIT;
	}

	public void setPoolable(boolean poolable) throws SQLException {

	}

	public boolean isPoolable() throws SQLException {
		return false; 
	}

	public void closeOnCompletion() throws SQLException {
		// TODO: implement
	}

	public boolean isCloseOnCompletion() throws SQLException {
		return false; // TODO: implement
	}

	public <T> T unwrap(Class<T> iface) throws SQLException {
		return null;
	}

	public boolean isWrapperFor(Class<?> iface) throws SQLException {
		return false;
	}
}
